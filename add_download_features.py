#!/usr/bin/env python3
"""
Script to add download functionality to all Chemlara apps
"""

import os
import re

# List of app files to update (excluding app_classification.py which is already done)
APP_FILES = [
    'app_regression.py',
    'app_classification_multiple.py',
    'app_graph_classification.py',
    'app_graph_multiclass.py',
    'app_graph_regression.py'
]

# Import statements to add (after existing imports)
IMPORT_ADDITIONS = """import zipfile
from datetime import datetime"""

# Helper functions to add (after other helper functions like format_time_duration)
HELPER_FUNCTIONS = '''
def create_model_report_zip(accuracy, precision, recall, f1, roc_auc=None, 
                             confusion_matrix_fig=None, roc_curve_fig=None,
                             feature_importance_fig=None, model_params=None):
    """Create a ZIP file containing all modeling outputs and reports"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # 1. Create metrics report (TXT)
        roc_auc_value = f"{roc_auc:.4f}" if roc_auc is not None else 'N/A'
        roc_auc_msg = f"Model discrimination ability ({roc_auc:.4f})" if roc_auc is not None else 'Not available'
        metrics_report = f"""
========================================
    CHEMLARA MODEL TRAINING REPORT
========================================
Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

MODEL PERFORMANCE METRICS
------------------------
Accuracy:  {accuracy:.4f}
Precision: {precision:.4f}
Recall:    {recall:.4f}
F1 Score:  {f1:.4f}
ROC AUC:   {roc_auc_value}

MODEL DESCRIPTION
-----------------
Type: AutoML Binary Classification (TPOT)
Optimization: Genetic Algorithm Pipeline Search
Cross-Validation: Stratified K-Fold

INTERPRETATION
--------------
- Accuracy: Overall model correctness ({accuracy*100:.2f}% of predictions are correct)
- Precision: {precision*100:.2f}% of positive predictions are actually positive  
- Recall: Model captures {recall*100:.2f}% of all actual positive cases
- F1 Score: Harmonic mean of precision and recall
- ROC AUC: {roc_auc_msg}

"""
        if model_params:
            metrics_report += f"\nMODEL PARAMETERS\n----------------\n"
            for key, value in model_params.items():
                metrics_report += f"{key}: {value}\n"
        
        zip_file.writestr(f"model_metrics_report_{timestamp}.txt", metrics_report)
        
        # 2. Create metrics CSV
        metrics_df = pd.DataFrame({
            'Metric': ['Accuracy', 'Precision', 'Recall', 'F1 Score', 'ROC AUC'],
            'Value': [accuracy, precision, recall, f1, roc_auc if roc_auc is not None else 0.0]
        })
        csv_buffer = io.StringIO()
        metrics_df.to_csv(csv_buffer, index=False)
        zip_file.writestr(f"model_metrics_{timestamp}.csv", csv_buffer.getvalue())
        
        # 3. Save confusion matrix figure
        if confusion_matrix_fig is not None:
            img_buffer = io.BytesIO()
            confusion_matrix_fig.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
            img_buffer.seek(0)
            zip_file.writestr(f"confusion_matrix_{timestamp}.png", img_buffer.getvalue())
        
        # 4. Save ROC curve figure
        if roc_curve_fig is not None:
            img_buffer = io.BytesIO()
            roc_curve_fig.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
            img_buffer.seek(0)
            zip_file.writestr(f"roc_curve_{timestamp}.png", img_buffer.getvalue())
        
        # 5. Save feature importance figure
        if feature_importance_fig is not None:
            img_buffer = io.BytesIO()
            feature_importance_fig.savefig(img_buffer, format='png', dpi=300, bbox_inches='tight')
            img_buffer.seek(0)
            zip_file.writestr(f"feature_importance_{timestamp}.png", img_buffer.getvalue())
        
        # 6. Create README
        readme_content = """
# Chemlara Model Training Report

This folder contains all outputs from your model training session.

## Files Included:

1. **model_metrics_report_[timestamp].txt** - Detailed text report with all metrics and interpretation
2. **model_metrics_[timestamp].csv** - Metrics in CSV format for easy import
3. **confusion_matrix_[timestamp].png** - Visual confusion matrix (if available)
4. **roc_curve_[timestamp].png** - ROC curve visualization (if available)
5. **feature_importance_[timestamp].png** - Feature importance plot (if available)

## How to Use:

- Review the text report for a complete summary
- Import the CSV into Excel or other tools for further analysis
- Use the PNG images in presentations or reports

Generated by Chemlara Predictor
"""
        zip_file.writestr("README.txt", readme_content)
    
    zip_buffer.seek(0)
    return zip_buffer

def create_prediction_report_zip(predictions_df, smiles_col='SMILES', 
                                   prediction_col='Predicted_Activity',
                                   confidence_col='Confidence',
                                   individual_structures=None):
    """Create a ZIP file containing all prediction outputs"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # 1. Save full predictions as CSV
        csv_buffer = io.StringIO()
        predictions_df.to_csv(csv_buffer, index=False)
        zip_file.writestr(f"predictions_{timestamp}.csv", csv_buffer.getvalue())
        
        # 2. Save predictions as Excel with formatting
        excel_buffer = io.BytesIO()
        with pd.ExcelWriter(excel_buffer, engine='openpyxl') as writer:
            predictions_df.to_excel(writer, index=False, sheet_name='Predictions')
        excel_buffer.seek(0)
        zip_file.writestr(f"predictions_{timestamp}.xlsx", excel_buffer.getvalue())
        
        # 3. Create summary statistics
        summary_stats = f"""
========================================
  CHEMLARA BATCH PREDICTION SUMMARY
========================================
Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

PREDICTION STATISTICS
--------------------
Total Molecules: {len(predictions_df)}
"""
        if prediction_col in predictions_df.columns:
            value_counts = predictions_df[prediction_col].value_counts()
            for category, count in value_counts.items():
                percentage = (count / len(predictions_df)) * 100
                summary_stats += f"{category}: {count} ({percentage:.1f}%)\\n"
        
        if confidence_col in predictions_df.columns:
            summary_stats += f"\\nCONFIDENCE STATISTICS\\n--------------------\\n"
            # Extract numeric confidence values
            try:
                confidences = predictions_df[confidence_col].apply(
                    lambda x: float(x.strip('%'))/100 if isinstance(x, str) and '%' in x else x
                )
                summary_stats += f"Mean Confidence: {confidences.mean():.2%}\\n"
                summary_stats += f"Min Confidence:  {confidences.min():.2%}\\n"
                summary_stats += f"Max Confidence:  {confidences.max():.2%}\\n"
            except:
                pass
        
        zip_file.writestr(f"prediction_summary_{timestamp}.txt", summary_stats)
        
        # 4. Save individual molecular structures if provided
        if individual_structures:
            structures_folder = "molecular_structures/"
            for idx, (smiles, img_bytes) in enumerate(individual_structures):
                if img_bytes:
                    zip_file.writestr(f"{structures_folder}molecule_{idx+1}.png", img_bytes)
        
        # 5. Create README
        readme_content = f"""
# Chemlara Batch Prediction Report

This folder contains all outputs from your batch prediction session.

## Files Included:

1. **predictions_{timestamp}.csv** - Predictions in CSV format
2. **predictions_{timestamp}.xlsx** - Predictions in Excel format with formatting
3. **prediction_summary_{timestamp}.txt** - Statistical summary of predictions
4. **molecular_structures/** - Individual molecular structure images (if available)

## Column Descriptions:

- **{smiles_col}**: Input SMILES string
- **{prediction_col}**: Predicted activity class
- **{confidence_col}**: Model confidence in prediction

## How to Use:

- Open the CSV/Excel file in your preferred spreadsheet software
- Review the summary for overall statistics
- View individual molecular structures in the structures folder

Generated by Chemlara Predictor
"""
        zip_file.writestr("README.txt", readme_content)
    
    zip_buffer.seek(0)
    return zip_buffer
'''

def add_imports(content):
    """Add zipfile and datetime imports if not present"""
    if 'import zipfile' not in content:
        # Find a good place to add imports (after other imports)
        import_pattern = r'(import random\n|import threading\n|from PIL import Image\n)'
        match = re.search(import_pattern, content)
        if match:
            insert_pos = match.end()
            content = content[:insert_pos] + IMPORT_ADDITIONS + '\n' + content[insert_pos:]
    return content

def add_helper_functions(content):
    """Add helper functions if not present"""
    if 'def create_model_report_zip' not in content:
        # Find where to insert (after format_time_duration function or similar)
        pattern = r'(def format_time_duration.*?return.*?\n)'
        match = re.search(pattern, content, re.DOTALL)
        if match:
            insert_pos = match.end()
            content = content[:insert_pos] + '\n' + HELPER_FUNCTIONS + '\n' + content[insert_pos:]
    return content

def process_file(filepath):
    """Process a single app file"""
    print(f"Processing {filepath}...")
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Add imports
        content = add_imports(content)
        
        # Add helper functions
        content = add_helper_functions(content)
        
        # Write back
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"✅ Successfully updated {filepath}")
        return True
    except Exception as e:
        print(f"❌ Error processing {filepath}: {e}")
        return False

def main():
    """Main function"""
    print("="*50)
    print("Adding Download Features to Chemlara Apps")
    print("="*50)
    
    success_count = 0
    for app_file in APP_FILES:
        if os.path.exists(app_file):
            if process_file(app_file):
                success_count += 1
        else:
            print(f"⚠️  File not found: {app_file}")
    
    print("\n" + "="*50)
    print(f"Completed: {success_count}/{len(APP_FILES)} files updated")
    print("="*50)
    
    print("\n📝 Next steps:")
    print("1. Review the changes in each file")
    print("2. Add download buttons in the UI where model results are displayed")
    print("3. Add download buttons in batch prediction sections")
    print("4. Test the functionality in each app")

if __name__ == "__main__":
    main()
